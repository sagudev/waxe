initSidebarItems({"enum":[["JSEngineError",""]],"fn":[["ToBoolean",""],["ToInt32",""],["ToInt64",""],["ToNumber",""],["ToString",""],["ToUint16",""],["ToUint32",""],["ToUint64",""],["ToWindowProxyIfWindow",""],["define_methods","Defines methods on `obj`. The last entry of `methods` must contain zeroed memory."],["define_properties","Defines attributes on `obj`. The last entry of `properties` must contain zeroed memory."],["describe_scripted_caller",""],["get_context_realm",""],["get_object_class",""],["get_object_realm",""],["is_dom_class",""],["is_dom_object",""],["is_window",""],["maybe_wrap_object_or_null_value",""],["maybe_wrap_object_value",""],["maybe_wrap_value",""],["report_warning",""],["transform_str_to_source_text",""],["transform_u16_to_source_text",""],["try_to_outerize",""]],"mod":[["jsapi_wrapped","Wrappers for JSAPI methods that accept lifetimed Handle and MutableHandle arguments. * * The wrapped methods are identical except that they accept Handle and MutableHandle arguments * that include lifetimes instead. Besides, they mutably borrow the mutable handles * instead of consuming/copying them. * * These wrappers are preferred, js::rust::wrappers should NOT be used. * "],["wrappers","Wrappers for JSAPI methods that should NOT be used. * * The wrapped methods are identical except that they accept Handle and MutableHandle arguments * that include lifetimes instead. * * They require MutableHandles to implement Copy. All code should migrate to jsapi_wrapped instead. * "]],"static":[["SIMPLE_GLOBAL_CLASS","This is a simple `JSClass` for global objects, primarily intended for tests."]],"struct":[["CapturedJSStack",""],["CompileOptionsWrapper",""],["CustomAutoRooter",""],["CustomAutoRooterGuard","An RAII guard used to root underlying data in `CustomAutoRooter` until the guard is dropped (falls out of scope). The underlying data can be accessed through this guard via its Deref and DerefMut implementations. This structure is created by `root` method on `CustomAutoRooter` or by the `auto_root!` macro."],["Handle",""],["IdVector",""],["JSEngine","A handle that must be kept alive in order to create new Runtimes. When this handle is dropped, the engine is shut down and cannot be reinitialized."],["JSEngineHandle",""],["MutableHandle",""],["ParentRuntime","A handle to a Runtime that will be used to create a new runtime in another thread. This handle and the new runtime must be destroyed before the original runtime can be dropped."],["RealmOptions",""],["RootedGuard","Rust API for keeping a Rooted value in the context's root stack. Example usage: `rooted!(in(cx) let x = UndefinedValue());`. `RootedGuard::new` also works, but the macro is preferred."],["RootedObjectVectorWrapper",""],["Runtime","A wrapper for the `JSContext` structure in SpiderMonkey."],["ScriptedCaller",""]],"trait":[["CustomTrace","Similarly to `Trace` trait, it's used to specify tracing of various types that are used in conjunction with `CustomAutoRooter`."],["GCMethods","A trait for types which can place appropriate GC barriers. * https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Internals/Garbage_collection#Incremental_marking * https://dxr.mozilla.org/mozilla-central/source/js/src/gc/Barrier.h"],["IntoHandle","Trait for things that can be converted to handles For any type `T: IntoHandle` we have an implementation of `From<T>` for `MutableHandle<T::Target>`. This is a way round the orphan rule."],["IntoMutableHandle",""],["Trace","Types that can be traced."]],"type":[["HandleFunction",""],["HandleId",""],["HandleObject",""],["HandleScript",""],["HandleString",""],["HandleSymbol",""],["HandleValue",""],["MutableHandleFunction",""],["MutableHandleId",""],["MutableHandleObject",""],["MutableHandleScript",""],["MutableHandleString",""],["MutableHandleSymbol",""],["MutableHandleValue",""],["SequenceRooter",""],["SequenceRooterGuard",""]]});