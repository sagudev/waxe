initSidebarItems({"constant":[["CorruptionCanaryForStatics_kCanarySet",""],["Vector_InlineLength",""]],"enum":[["LinkedListElement_NodeKind",""],["MemoryOrdering","An enum of memory ordering possibilities for atomics."],["NotNullTag",""],["Vector__bindgen_ty_1",""]],"mod":[["detail",""],["ipc",""],["recordreplay",""],["span_details",""],["tl",""]],"static":[["VariantIndex_index",""]],"struct":[["AddLvalueReference","AddLvalueReference adds an lvalue & reference to T if one isn't already present. (Note: adding an lvalue reference to an rvalue && reference in essence replaces the && with a &&, per C+11 reference collapsing rules. For example, int&& would become int&.)"],["AddPointer","Converts T& to T*. Otherwise returns T* given T. Note that C++17 wants std::add_pointer to work differently for function types. We don't implement that behavior here."],["AddRvalueReference","AddRvalueReference adds an rvalue && reference to T if one isn't already present. (Note: adding an rvalue reference to an lvalue & reference in essence keeps the &, per C+11 reference collapsing rules. For example, int& would remain int&.)"],["AlignedStorage2",""],["AlignmentFinder",""],["AlignmentFinder_Aligner",""],["AutoCleanLinkedList",""],["BaseTimeDuration","Instances of this class represent the length of an interval of time. Negative durations are allowed, meaning the end is before the start."],["BaseTimeDurationPlatformUtils","Platform-specific implementation details of BaseTimeDuration."],["BaseTimeDuration__SomethingVeryRandomHere",""],["BigEndian",""],["BufferList",""],["BufferList_IterImpl",""],["BufferList_Segment",""],["CStringHasher",""],["CorruptionCanary","This class is designed to cause crashes when various kinds of memory corruption are observed. For instance, let's say we have a class C where we suspect out-of-bounds writes to some members.  We can insert a member of type Poison near the members we suspect are being corrupted by out-of-bounds writes.  Or perhaps we have a class K we suspect is subject to use-after-free violations, in which case it doesn't particularly matter where in the class we add the member of type Poison."],["CorruptionCanaryForStatics","A version of CorruptionCanary that is suitable as a member of objects that are statically allocated."],["DebugOnly","DebugOnly contains a value of type T, but only in debug builds.  In release builds, it does not contain a value.  This helper is intended to be used with MOZ_ASSERT()-style macros, allowing one to write:"],["Decay","Strips const/volatile off a type and decays it from an lvalue to an rvalue. So function types are converted to function pointers, arrays to pointers, and references are removed."],["DefaultDelete","A default deletion policy using plain old operator delete."],["DefaultHasher",""],["FallibleHashMethods",""],["FloatingPoint",""],["FunctionTypeTraits",""],["GenericErrorResult","A type that auto-converts to an error Result. This is like a Result without a success type. It's the best return type for functions that always return an error--functions designed to build and populate error objects. It's also useful in error-handling macros; see MOZ_TRY for an example."],["HashCodeScrambler","A pseudorandom function mapping 32-bit integers to 32-bit integers."],["HashCodeScrambler_SipHasher",""],["HashMap",""],["HashMapEntry",""],["HashMap_MapHashPolicy",""],["HashSet",""],["HashSet_SetHashPolicy",""],["IsArithmetic","IsArithmetic determines whether a type is arithmetic.  A type is arithmetic iff it is an integral type or a floating point type."],["IsArray","IsArray determines whether a type is an array type, of known or unknown length."],["IsBaseOf",""],["IsClass","IsClass determines whether a type is a class type (but not a union)."],["IsConst","IsConst determines whether a type is const or not."],["IsConvertible","IsConvertible determines whether a value of type From will implicitly convert to a value of type To.  For example:"],["IsDefaultConstructible","IsDefaultConstructible determines whether a type has a public default constructor."],["IsDestructible","IsDestructible determines whether a type has a public destructor."],["IsEmpty","IsEmpty determines whether a type is a class (but not a union) that is empty."],["IsEnum","IsEnum determines whether a type is an enum type."],["IsFloatingPoint","IsFloatingPoint determines whether a type is a floating point type (float, double, long double)."],["IsFunction","IsFunction determines whether a type is a function type. Function pointers don't qualify here--only the type of an actual function symbol. We do not correctly handle varags function types because of a bug in MSVC."],["IsIntegral","IsIntegral determines whether a type is an integral type."],["IsLvalueReference","IsLvalueReference determines whether a type is an lvalue reference."],["IsMemberPointer","IsMemberPointer determines whether a type is pointer to non-static member object or a pointer to non-static member function."],["IsPod","Traits class for identifying POD types.  Until C++11 there's no automatic way to detect PODs, so for the moment this is done manually.  Users may define specializations of this class that inherit from mozilla::TrueType and mozilla::FalseType (or equivalently mozilla::IntegralConstant<bool, true or false>, or conveniently from mozilla::IsPod for composite types) as needed to ensure correct IsPod behavior."],["IsPointer","IsPointer determines whether a type is a possibly-CV-qualified pointer type (but not a pointer-to-member type)."],["IsReference","IsReference determines whether a type is an lvalue or rvalue reference."],["IsRvalueReference","IsRvalueReference determines whether a type is an rvalue reference."],["IsSame","IsSame tests whether two types are the same type."],["IsScalar","IsScalar determines whether a type is a scalar type."],["IsSigned","IsSigned determines whether a type is a signed arithmetic type.  |char| is considered a signed type if it has the same representation as |signed char|."],["IsUnsigned","IsUnsigned determines whether a type is an unsigned arithmetic type."],["IsVoid","IsVoid determines whether a type is void."],["IsVolatile","IsVolatile determines whether a type is volatile or not."],["LinkedList",""],["LinkedListElement",""],["LinkedList_Iterator",""],["LittleEndian",""],["MakeSigned","MakeSigned produces the corresponding signed integer type for a given integral type T, with the const/volatile qualifiers of T.  T must be a possibly-const/volatile-qualified integral type that isn't bool."],["MakeUnsigned","MakeUnsigned produces the corresponding unsigned integer type for a given integral type T, with the const/volatile qualifiers of T.  T must be a possibly-const/volatile-qualified integral type that isn't bool."],["MallocAllocPolicy",""],["MaxValue","MaxValue returns the maximum value of the given integer type as a compile-time constant, which std::numeric_limits::max() cannot do in c++98."],["Maybe",""],["MinValue","MinValue returns the minimum value of the given integer type as a compile-time constant, which std::numeric_limits::min() cannot do in c++98."],["NativeEndian",""],["NeverAllocPolicy",""],["Nothing",""],["Ok","Empty struct, indicating success for operations that have no return value. For example, if you declare another empty struct `struct OutOfMemory {};`, then `Result<Ok, OutOfMemory>` represents either success or OOM."],["Opaque","Opaque is a replacement for integral T in cases where only comparisons must be supported, and it's desirable to prevent accidental dependency on exact values."],["OwningNonNull",""],["Pair","Pair is the logical concatenation of an instance of A with an instance B. Space is conserved when possible.  Neither A nor B may be a final class."],["PointerHasher",""],["PositionOfSignBit",""],["Range",""],["RangedPtr",""],["ReentrancyGuard",""],["RefPtrTraits",""],["RemoveCV","RemoveCV removes top-level const and volatile qualifications on a type."],["RemoveConst","RemoveConst removes top-level const qualifications on a type."],["RemoveExtent","RemoveExtent produces either the type of the elements of the array T, or T itself."],["RemovePointer","Produces the pointed-to type if a pointer is provided, else returns the input type.  Note that this does not dereference pointer-to-member pointers."],["RemoveReference","Converts reference types to the underlying types."],["RemoveVolatile","RemoveVolatile removes top-level volatile qualifications on a type."],["Result","Result<V, E> represents the outcome of an operation that can either succeed or fail. It contains either a success value of type V or an error value of type E."],["ReverseIterator",""],["ScopeExit",""],["Span_storage_type",""],["StaticLocalRefPtr",""],["StaticRefPtr",""],["TimeDurationValueCalculator","Perform arithmetic operations on the value of a BaseTimeDuration without doing strict checks on the range of values."],["TimeStamp","Instances of this class represent moments in time, or a special \"null\" moment. We do not use the non-monotonic system clock or local time, since they can be reset, causing apparent backward travel in time, which can confuse algorithms. Instead we measure elapsed time according to the system.  This time can never go backwards (i.e. it never wraps around, at least not in less than five million years of system elapsed time). It might not advance while the system is sleeping. If TimeStamp::SetNow() is not called at all for hours or days, we might not notice the passage of some of that time."],["TimeStamp63Bit",""],["Tuple","Tuple is a class that stores zero or more objects, whose types are specified as template parameters. It can be thought of as a generalization of Pair, (which can be thought of as a 2-tuple)."],["UniquePtr","UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be transferred out of a UniquePtr through explicit action, but otherwise the resource is destroyed when the UniquePtr is destroyed."],["Variant","mozilla::Variant"],["VariantType",""],["Vector_CapacityAndReserved",""],["Vector_ConstRange",""],["Vector_Range",""],["unused_t",""]],"type":[["AddPointer_Type",""],["Array_const_iterator",""],["Array_const_reverse_iterator",""],["Array_iterator",""],["Array_reverse_iterator",""],["AutoCleanLinkedList_ClientType",""],["AutoCleanLinkedList_Traits",""],["CStringHasher_Key",""],["CStringHasher_Lookup",""],["Conditional_Type",""],["DefaultHasher_Lookup",""],["EnumeratedArray_ArrayType",""],["EnumeratedArray_const_iterator",""],["EnumeratedArray_const_reverse_iterator",""],["EnumeratedArray_iterator",""],["EnumeratedArray_reverse_iterator",""],["FalseType",""],["FloatingPoint_Base",""],["FloatingPoint_Bits","An unsigned integral type suitable for accessing the bitwise representation of T."],["Generation",""],["HashMapEntry_KeyType",""],["HashMapEntry_ValueType",""],["HashMap_AddPtr",""],["HashMap_Entry",""],["HashMap_Enum",""],["HashMap_Impl",""],["HashMap_Iterator",""],["HashMap_Lookup",""],["HashMap_MapHashPolicy_Base",""],["HashMap_MapHashPolicy_KeyType",""],["HashMap_ModIterator",""],["HashMap_Ptr",""],["HashMap_Range",""],["HashMap_TableEntry",""],["HashNumber",""],["HashSet_AddPtr",""],["HashSet_Entry",""],["HashSet_Enum",""],["HashSet_Impl",""],["HashSet_Iterator",""],["HashSet_Lookup",""],["HashSet_ModIterator",""],["HashSet_Ptr",""],["HashSet_Range",""],["HashSet_SetHashPolicy_Base",""],["HashSet_SetHashPolicy_KeyType",""],["InfinityBits_Traits",""],["IntegralConstant_Type",""],["IntegralConstant_ValueType",""],["LinkedListElement_ClientType",""],["LinkedListElement_ConstClientType",""],["LinkedListElement_ConstRawType",""],["LinkedListElement_RawType",""],["LinkedListElement_Traits",""],["LinkedList_ClientType",""],["LinkedList_ConstClientType",""],["LinkedList_ConstElementType",""],["LinkedList_ConstRawType",""],["LinkedList_ElementType",""],["LinkedList_RawType",""],["LinkedList_Traits",""],["MallocSizeOf",""],["Maybe_ValueType",""],["MinValue_UnsignedIntegerType",""],["NativeEndian_super",""],["NetworkEndian",""],["Pair_Base",""],["PointerHasher_Lookup",""],["RemoveCV_Type",""],["RemoveConst_Type",""],["RemoveExtent_Type",""],["RemoveReference_Type",""],["RemoveVolatile_Type",""],["Result_Impl",""],["Span_const_iterator",""],["Span_const_reverse_iterator",""],["Span_element_type",""],["Span_index_type",""],["Span_iterator",""],["Span_pointer",""],["Span_reference",""],["Span_reverse_iterator",""],["SpecificNaNBits_Traits",""],["TimeDuration","Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for arithmetic on the mValue member."],["TimeStampValue",""],["TrueType","Convenient aliases."],["Tuple_Impl",""],["UniquePtr_DeleterType",""],["UniquePtr_ElementType",""],["UniquePtr_Pointer",""],["VariantType_Type",""],["Variant_Impl",""],["Variant_Tag",""],["Vector_ElementType",""],["Vector_Impl",""]],"union":[["AlignedStorage2_U",""],["Utf8Unit","A code unit within a UTF-8 encoded string.  (A code unit is the smallest unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit number; for UTF-16 it would be a 16-bit number.)"]]});